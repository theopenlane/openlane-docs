---
title: Field-Level Encryption
description: Configure transparent field encryption using Google Tink with envelope encryption
sidebar_position: 2
---

# Field-Level Encryption System

This document describes the configurable field-level encryption system for Ent schemas using Google's Tink cryptographic library, providing transparent encryption and decryption of sensitive data with envelope encryption for key rotation support.

## Overview

The hush field-level encryption system provides:

* **Transparent Encryption**: Automatic encryption on write operations using Google Tink
* **Transparent Decryption**: Automatic decryption on read operations
* **Optional Encryption**: Encryption is only active when a keyset is configured
* **Graceful Degradation**: System operates normally without encryption when no keyset is provided
* **Envelope Encryption**: Support for key rotation without re-encrypting data
* **Configurable Fields**: Simple annotation-based field encryption
* **Multiple Backends**: Support for both Tink (primary) and GoCloud secrets
* **Base64 Storage**: Safe database storage of encrypted binary data
* **Migration Support**: Tools for encrypting existing unencrypted data

## Quick Start

### 1. Generate a Tink Keyset

```bash
# Generate a new Tink keyset for encryption
go run ./internal/ent/hush/cmd/hush generate

# Example output:
# OPENLANE_TINK_KEYSET=CNnD/p0JEmQKWAowdHlwZS5nb29nbGVhcGlzLmNvbS9nb29nbGUuY3J5cHRvLnRpbmsuQWVzR2NtS2V5EiIaID+JaHu+6zMW3YgphNkpL5lVJMVeZdAjJclgAHyShxUOGAEQARjZw/6dCSAB
```

### 1. Set Environment Variable

```bash
export OPENLANE_TINK_KEYSET=CNnD/p0JEmQKWAowdHlwZS5nb29nbGVhcGlzLmNvbS9nb29nbGUuY3J5cHRvLnRpbmsuQWVzR2NtS2V5EiIaID+JaHu+6zMW3YgphNkpL5lVJMVeZdAjJclgAHyShxUOGAEQARjZw/6dCSAB
```

### 1. Add Encryption to Schema

```go
package schema

import (
    "entgo.io/ent"
    "entgo.io/ent/schema/field"
    "github.com/theopenlane/core/internal/ent/hush"
)

type SecretStore struct {
    ent.Schema
}

func (SecretStore) Fields() []ent.Field {
    return []ent.Field{
        field.String("name"),
        field.String("api_key").
            Sensitive().
            Annotations(
                hush.EncryptField(), // Enable encryption
            ),
    }
}

func (SecretStore) Mixin() []ent.Mixin {
    return []ent.Mixin{
        NewAutoHushEncryptionMixin(SecretStore{}), // Auto-detect encrypted fields
    }
}
```

## Usage

### Method 1: Field Annotations (Recommended)

Use the `hush.EncryptField()` annotation to mark fields for encryption:

```go
func (MySchema) Fields() []ent.Field {
    return []ent.Field{
        field.String("public_data"),
        field.String("secret_key").
            Sensitive().
            Annotations(
                hush.EncryptField(),
            ),
        field.String("api_token").
            Sensitive().
            Optional().
            Annotations(
                hush.EncryptField(),
            ),
    }
}

func (MySchema) Mixin() []ent.Mixin {
    return []ent.Mixin{
        NewAutoHushEncryptionMixin(MySchema{}),
    }
}
```

### Method 2: Pre-configured Mixins

Use built-in mixins for common encrypted field patterns:

```go
func (OAuthApp) Mixin() []ent.Mixin {
    return []ent.Mixin{
        ClientCredentialsMixin(), // Adds encrypted client_secret
        TokenMixin(),            // Adds encrypted access_token, refresh_token
        APIKeyMixin(),          // Adds encrypted api_key
    }
}
```

### Method 3: Custom Encryption Mixins

Create custom mixins for specific field configurations:

```go
func (MySchema) Mixin() []ent.Mixin {
    return []ent.Mixin{
        NewEncryptionMixin(
            EncryptedField{
                Name:      "webhook_secret",
                Optional:  true,
                Sensitive: true,
                Immutable: false,
            },
            EncryptedField{
                Name:      "private_key",
                Optional:  false,
                Sensitive: true,
                Immutable: true,
            },
        ),
    }
}
```

## Security Model

### Encryption Details

* **Library**: Google Tink (cryptographic library)
* **Algorithm**: AES-256-GCM with AEAD (Authenticated Encryption with Associated Data)
* **Key Management**: Envelope encryption with key rotation support
* **Nonce**: Automatically managed by Tink (unique per encryption)
* **Authentication**: Built-in via AEAD
* **Storage**: Base64 encoding for safe database storage

### Why Base64 Encoding?

Encrypted data is binary and may contain:
- Null bytes (`\0`) that databases interpret as string terminators
- Invalid UTF-8 sequences that cause encoding errors
- Control characters that break text protocols

Base64 encoding ensures encrypted data is stored safely as text in any database.

## Key Management

### Tink Keyset Generation

```bash
# Generate a new keyset
go run ./internal/ent/hush/cmd/hush generate

# Output includes the base64-encoded keyset
OPENLANE_TINK_KEYSET=<base64-encoded-keyset>
```
### Key Rotation

Tink's envelope encryption enables key rotation without re-encrypting existing data:

1. **Generate New Keyset**
   ```bash
   go run ./internal/ent/hush/cmd/hush generate
   ```

2. **Add to Existing Keyset**
   ```go
   // Tink handles multiple keys automatically
   // New data uses new key, old data still decryptable
   ```

3. **Update Environment**
   ```bash
   export OPENLANE_TINK_KEYSET=<new-keyset-with-both-keys>
   ```

## Configuration

### Environment Variables

```bash
# Optional: Tink keyset for encryption
# If not set, encryption will be disabled and data will be stored as plaintext
OPENLANE_TINK_KEYSET=<base64-encoded-keyset>

# Optional: GoCloud secrets URL (overrides Tink)
SECRETS_URL=gcpkms://projects/PROJECT/locations/global/keyRings/RING/cryptoKeys/KEY
```

### Encryption Behavior

#### When `OPENLANE_TINK_KEYSET` is set:
- All fields marked with `hush.EncryptField()` are encrypted before storage
- Data is stored as base64-encoded ciphertext in the database
- Decryption happens automatically when reading data

#### When `OPENLANE_TINK_KEYSET` is NOT set:
- Encryption is completely disabled
- Fields marked with `hush.EncryptField()` are stored as plaintext
- No encryption or decryption operations occur
- System operates normally without any errors

**WARNING**: Be consistent with your encryption configuration:
- If you start with encryption enabled, keep it enabled to access encrypted data
- If you start without encryption, enabling it later will only encrypt new/updated data
- Disabling encryption after data is encrypted will make that data unreadable

## Migration

### Migration Scenarios

#### Enabling Encryption (No Keyset → With Keyset)

When you enable encryption for the first time:

1. Set `OPENLANE_TINK_KEYSET` environment variable
2. Existing plaintext data remains readable (migration hook detects unencrypted data)
3. New/updated data will be encrypted
4. Over time, all data becomes encrypted as records are updated

#### Disabling Encryption (With Keyset → No Keyset)

**WARNING**: This makes encrypted data unreadable!

If you remove the `OPENLANE_TINK_KEYSET`:
- Existing encrypted data appears as base64 strings
- New data is stored as plaintext
- The system continues to function but encrypted data is inaccessible
