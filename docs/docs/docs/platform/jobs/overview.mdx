---
title: Overview
description: Job management, automation, and workflow orchestration
sidebar_position: 1
---

# Job Management

Openlane provides comprehensive job management capabilities for automating compliance workflows, scheduling recurring tasks, and executing background processes. The job system consists of three main components: **Job Runners** for execution infrastructure, **Job Templates** for reusable job definitions, and **Scheduled Jobs** for automated execution.

## What is Job Management?

The job management system enables organizations to automate compliance activities, execute recurring tasks, and orchestrate complex workflows across the platform. It provides reliable, scalable infrastructure for background processing and task automation.

## Core Components

### Job Runners
Job Runners are execution environments that process jobs and tasks. They provide the compute infrastructure and runtime environment for job execution.

### Job Templates
Job Templates define reusable job configurations, parameters, and execution logic that can be instantiated for specific tasks.

### Scheduled Jobs
Scheduled Jobs automate the execution of job templates based on time-based triggers, events, or conditions.

## Key Features

- **Automated Workflows**: Execute complex compliance workflows automatically
- **Scheduling**: Time-based and event-based job scheduling
- **Scalability**: Distributed job execution across multiple runners
- **Monitoring**: Real-time job status tracking and logging
- **Templates**: Reusable job definitions for common tasks
- **Integration**: Native integration with platform objects and external systems

## Job Types

### Compliance Automation Jobs
- **Control Testing**: Automated control effectiveness testing
- **Evidence Collection**: Scheduled evidence gathering and validation
- **Risk Assessment**: Automated risk scoring and assessment updates
- **Audit Preparation**: Automated audit documentation and report generation

### Data Processing Jobs
- **Data Import/Export**: Bulk data processing and synchronization
- **Report Generation**: Scheduled compliance reports and dashboards
- **Data Validation**: Automated data quality checks and validation
- **Backup Operations**: Automated backup and archival processes

### Integration Jobs
- **Third-Party Sync**: Synchronization with external systems and APIs
- **Notification Delivery**: Automated alerts and communication delivery
- **System Monitoring**: Health checks and system status monitoring
- **Maintenance Tasks**: Routine system maintenance and cleanup

## GraphQL Operations

### Job Runners

#### Query Job Runners
```graphql
query GetJobRunners($first: Int, $where: JobRunnerWhereInput) {
  jobRunners(first: $first, where: $where) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
    edges {
      node {
        id
        name
        description
        status
        platform
        version
        lastHeartbeat
        capabilities
        createdAt
        updatedAt
      }
    }
  }
}
```

#### Create Job Runner
```graphql
mutation CreateJobRunner($input: CreateJobRunnerInput!) {
  createJobRunner(input: $input) {
    jobRunner {
      id
      name
      description
      status
      platform
      version
      capabilities
      createdAt
    }
  }
}
```

### Job Templates

#### Query Job Templates
```graphql
query GetJobTemplates($first: Int, $where: JobTemplateWhereInput) {
  jobTemplates(first: $first, where: $where) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
    edges {
      node {
        id
        name
        description
        templateType
        config
        parameters
        createdAt
        updatedAt
      }
    }
  }
}
```

#### Create Job Template
```graphql
mutation CreateJobTemplate($input: CreateJobTemplateInput!) {
  createJobTemplate(input: $input) {
    jobTemplate {
      id
      name
      description
      templateType
      config
      parameters
      createdAt
    }
  }
}
```

### Scheduled Jobs

#### Query Scheduled Jobs
```graphql
query GetScheduledJobs($first: Int, $where: ScheduledJobWhereInput) {
  scheduledJobs(first: $first, where: $where) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
    edges {
      node {
        id
        name
        description
        schedule
        enabled
        lastRun
        nextRun
        status
        jobTemplate {
          id
          name
          templateType
        }
        createdAt
        updatedAt
      }
    }
  }
}
```

#### Create Scheduled Job
```graphql
mutation CreateScheduledJob($input: CreateScheduledJobInput!) {
  createScheduledJob(input: $input) {
    scheduledJob {
      id
      name
      description
      schedule
      enabled
      jobTemplateID
      createdAt
    }
  }
}
```

## API Usage Examples

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

### Job Runner Management

<Tabs>
<TabItem value="golang" label="Go">

```go
package main

import (
    "context"
    "fmt"
    "log"
    "time"

    "github.com/theopenlane/core/pkg/openlaneclient"
)

// JobManager handles job operations and orchestration
type JobManager struct {
    client *openlaneclient.OpenlaneClient
}

// RegisterJobRunner registers a new job runner with the platform
func (jm *JobManager) RegisterJobRunner(ctx context.Context, runnerConfig *JobRunnerConfig) (*generated.JobRunner, error) {
    input := openlaneclient.CreateJobRunnerInput{
        Name:         runnerConfig.Name,
        Description:  openlaneclient.Ptr(runnerConfig.Description),
        Status:       openlaneclient.JobRunnerStatusACTIVE,
        Platform:     runnerConfig.Platform,
        Version:      openlaneclient.Ptr(runnerConfig.Version),
        Capabilities: runnerConfig.Capabilities,
    }

    runner, err := jm.client.CreateJobRunner(ctx, input)
    if err != nil {
        return nil, fmt.Errorf("failed to register job runner: %w", err)
    }

    log.Printf("Registered job runner: %s (%s)", runner.Name, runner.ID)
    return runner, nil
}

// CreateJobTemplate creates a reusable job template
func (jm *JobManager) CreateJobTemplate(ctx context.Context, templateConfig *JobTemplateConfig) (*generated.JobTemplate, error) {
    configJSON, err := json.Marshal(templateConfig.Config)
    if err != nil {
        return nil, fmt.Errorf("failed to marshal job config: %w", err)
    }

    parametersJSON, err := json.Marshal(templateConfig.Parameters)
    if err != nil {
        return nil, fmt.Errorf("failed to marshal job parameters: %w", err)
    }

    input := openlaneclient.CreateJobTemplateInput{
        Name:         templateConfig.Name,
        Description:  openlaneclient.Ptr(templateConfig.Description),
        TemplateType: templateConfig.TemplateType,
        Config:       configJSON,
        Parameters:   parametersJSON,
    }

    template, err := jm.client.CreateJobTemplate(ctx, input)
    if err != nil {
        return nil, fmt.Errorf("failed to create job template: %w", err)
    }

    log.Printf("Created job template: %s (%s)", template.Name, template.ID)
    return template, nil
}

// ScheduleRecurringJob creates a scheduled job for automated execution
func (jm *JobManager) ScheduleRecurringJob(ctx context.Context, scheduleConfig *ScheduledJobConfig) (*generated.ScheduledJob, error) {
    input := openlaneclient.CreateScheduledJobInput{
        Name:          scheduleConfig.Name,
        Description:   openlaneclient.Ptr(scheduleConfig.Description),
        Schedule:      scheduleConfig.CronSchedule,
        Enabled:       openlaneclient.Ptr(true),
        JobTemplateID: scheduleConfig.JobTemplateID,
    }

    scheduledJob, err := jm.client.CreateScheduledJob(ctx, input)
    if err != nil {
        return nil, fmt.Errorf("failed to create scheduled job: %w", err)
    }

    log.Printf("Created scheduled job: %s (%s)", scheduledJob.Name, scheduledJob.ID)
    return scheduledJob, nil
}

// ExecuteJobTemplate executes a job template immediately
func (jm *JobManager) ExecuteJobTemplate(ctx context.Context, templateID string, parameters map[string]interface{}) (*JobExecutionInfo, error) {
    // Get available job runners
    runners, err := jm.GetAvailableJobRunners(ctx)
    if err != nil {
        return nil, fmt.Errorf("failed to get available job runners: %w", err)
    }

    if len(runners) == 0 {
        return nil, fmt.Errorf("no available job runners for execution")
    }

    // Select optimal job runner (simplified selection)
    selectedRunner := runners[0]

    // Create job execution record
    executionInfo := &JobExecutionInfo{
        JobTemplateID: templateID,
        JobRunnerID:   selectedRunner.ID,
        Parameters:    parameters,
        Status:        "QUEUED",
        StartTime:     time.Now(),
    }

    // Submit job to runner (this would involve actual job submission logic)
    log.Printf("Submitting job template %s to runner %s", templateID, selectedRunner.ID)

    return executionInfo, nil
}

// GetAvailableJobRunners retrieves active job runners
func (jm *JobManager) GetAvailableJobRunners(ctx context.Context) ([]*generated.JobRunner, error) {
    where := openlaneclient.JobRunnerWhereInput{
        Status: &openlaneclient.JobRunnerStatusFilterInput{
            Eq: openlaneclient.Ptr(openlaneclient.JobRunnerStatusACTIVE),
        },
    }

    result, err := jm.client.GetJobRunners(ctx, &where)
    if err != nil {
        return nil, fmt.Errorf("failed to get job runners: %w", err)
    }

    var runners []*generated.JobRunner
    for _, edge := range result.JobRunners.Edges {
        // Check if runner has recent heartbeat (within last 5 minutes)
        if edge.Node.LastHeartbeat != nil {
            timeSinceHeartbeat := time.Since(*edge.Node.LastHeartbeat)
            if timeSinceHeartbeat <= 5*time.Minute {
                runners = append(runners, edge.Node)
            }
        }
    }

    return runners, nil
}

// Configuration types
type JobRunnerConfig struct {
    Name         string
    Description  string
    Platform     openlaneclient.JobPlatformType
    Version      string
    Capabilities []string
}

type JobTemplateConfig struct {
    Name         string
    Description  string
    TemplateType string
    Config       map[string]interface{}
    Parameters   map[string]interface{}
}

type ScheduledJobConfig struct {
    Name          string
    Description   string
    CronSchedule  string
    JobTemplateID string
}

type JobExecutionInfo struct {
    JobTemplateID string
    JobRunnerID   string
    Parameters    map[string]interface{}
    Status        string
    StartTime     time.Time
    EndTime       *time.Time
    Result        map[string]interface{}
    Error         *string
}
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
// Job management and automation
class JobManager {
  constructor(client) {
    this.client = client;
  }

  async registerJobRunner(runnerConfig) {
    const input = {
      name: runnerConfig.name,
      description: runnerConfig.description,
      status: 'ACTIVE',
      platform: runnerConfig.platform,
      version: runnerConfig.version,
      capabilities: runnerConfig.capabilities
    };

    const runner = await this.client.createJobRunner(input);
    console.log(`Registered job runner: ${runner.name} (${runner.id})`);
    return runner;
  }

  async createJobTemplate(templateConfig) {
    const input = {
      name: templateConfig.name,
      description: templateConfig.description,
      templateType: templateConfig.templateType,
      config: JSON.stringify(templateConfig.config),
      parameters: JSON.stringify(templateConfig.parameters)
    };

    const template = await this.client.createJobTemplate(input);
    console.log(`Created job template: ${template.name} (${template.id})`);
    return template;
  }

  async scheduleRecurringJob(scheduleConfig) {
    const input = {
      name: scheduleConfig.name,
      description: scheduleConfig.description,
      schedule: scheduleConfig.cronSchedule,
      enabled: true,
      jobTemplateId: scheduleConfig.jobTemplateId
    };

    const scheduledJob = await this.client.createScheduledJob(input);
    console.log(`Created scheduled job: ${scheduledJob.name} (${scheduledJob.id})`);
    return scheduledJob;
  }
}
```

</TabItem>
</Tabs>

### Compliance Automation

<Tabs>
<TabItem value="golang" label="Go">

```go
// ComplianceJobManager handles compliance-specific job automation
type ComplianceJobManager struct {
    jobManager *JobManager
}

// SetupComplianceJobTemplates creates standard compliance job templates
func (cjm *ComplianceJobManager) SetupComplianceJobTemplates(ctx context.Context) error {
    // Control testing job template
    controlTestingTemplate := &JobTemplateConfig{
        Name:         "Control Testing Automation",
        Description:  "Automated testing of control effectiveness",
        TemplateType: "COMPLIANCE_TESTING",
        Config: map[string]interface{}{
            "test_type":     "automated",
            "frameworks":    []string{"SOC2", "ISO27001"},
            "notification":  true,
            "evidence_required": true,
        },
        Parameters: map[string]interface{}{
            "control_ids":    []string{},
            "test_frequency": "monthly",
            "evidence_types": []string{"screenshot", "log", "document"},
        },
    }

    _, err := cjm.jobManager.CreateJobTemplate(ctx, controlTestingTemplate)
    if err != nil {
        return fmt.Errorf("failed to create control testing template: %w", err)
    }

    // Evidence collection job template
    evidenceCollectionTemplate := &JobTemplateConfig{
        Name:         "Evidence Collection Automation",
        Description:  "Automated collection and validation of compliance evidence",
        TemplateType: "EVIDENCE_COLLECTION",
        Config: map[string]interface{}{
            "collection_methods": []string{"api", "file_system", "database"},
            "validation_rules":   []string{"completeness", "accuracy", "timeliness"},
            "storage_location":   "s3://compliance-evidence/",
        },
        Parameters: map[string]interface{}{
            "evidence_sources": []string{},
            "collection_schedule": "daily",
            "retention_period": "7_years",
        },
    }

    _, err = cjm.jobManager.CreateJobTemplate(ctx, evidenceCollectionTemplate)
    if err != nil {
        return fmt.Errorf("failed to create evidence collection template: %w", err)
    }

    // Risk assessment job template
    riskAssessmentTemplate := &JobTemplateConfig{
        Name:         "Risk Assessment Automation",
        Description:  "Automated risk scoring and assessment updates",
        TemplateType: "RISK_ASSESSMENT",
        Config: map[string]interface{}{
            "assessment_criteria": []string{"impact", "likelihood", "controls"},
            "scoring_method":      "quantitative",
            "update_frequency":    "weekly",
        },
        Parameters: map[string]interface{}{
            "risk_categories": []string{},
            "scoring_weights": map[string]float64{
                "impact":     0.4,
                "likelihood": 0.4,
                "controls":   0.2,
            },
        },
    }

    _, err = cjm.jobManager.CreateJobTemplate(ctx, riskAssessmentTemplate)
    if err != nil {
        return fmt.Errorf("failed to create risk assessment template: %w", err)
    }

    log.Println("Successfully created compliance job templates")
    return nil
}

// ScheduleComplianceJobs sets up automated compliance job schedules
func (cjm *ComplianceJobManager) ScheduleComplianceJobs(ctx context.Context, programID string) error {
    // Get compliance job templates
    templates, err := cjm.getComplianceJobTemplates(ctx)
    if err != nil {
        return fmt.Errorf("failed to get compliance job templates: %w", err)
    }

    schedules := []struct {
        name     string
        template string
        cron     string
    }{
        {"Daily Evidence Collection", "evidence_collection", "0 2 * * *"},      // 2 AM daily
        {"Weekly Control Testing", "control_testing", "0 3 * * 1"},           // 3 AM Mondays
        {"Monthly Risk Assessment", "risk_assessment", "0 4 1 * *"},           // 4 AM 1st of month
    }

    for _, schedule := range schedules {
        templateID := cjm.findTemplateByType(templates, schedule.template)
        if templateID == "" {
            log.Printf("Warning: template not found for %s", schedule.template)
            continue
        }

        scheduleConfig := &ScheduledJobConfig{
            Name:          fmt.Sprintf("%s - Program %s", schedule.name, programID),
            Description:   fmt.Sprintf("Automated %s for compliance program %s", schedule.name, programID),
            CronSchedule:  schedule.cron,
            JobTemplateID: templateID,
        }

        _, err := cjm.jobManager.ScheduleRecurringJob(ctx, scheduleConfig)
        if err != nil {
            log.Printf("Warning: failed to schedule %s: %v", schedule.name, err)
            continue
        }

        log.Printf("Scheduled %s for program %s", schedule.name, programID)
    }

    return nil
}

// getComplianceJobTemplates retrieves compliance-related job templates
func (cjm *ComplianceJobManager) getComplianceJobTemplates(ctx context.Context) ([]*generated.JobTemplate, error) {
    where := openlaneclient.JobTemplateWhereInput{
        TemplateType: &openlaneclient.StringFilterInput{
            In: []string{"COMPLIANCE_TESTING", "EVIDENCE_COLLECTION", "RISK_ASSESSMENT"},
        },
    }

    result, err := cjm.jobManager.client.GetJobTemplates(ctx, &where)
    if err != nil {
        return nil, fmt.Errorf("failed to get job templates: %w", err)
    }

    var templates []*generated.JobTemplate
    for _, edge := range result.JobTemplates.Edges {
        templates = append(templates, edge.Node)
    }

    return templates, nil
}

// findTemplateByType finds a job template by its type
func (cjm *ComplianceJobManager) findTemplateByType(templates []*generated.JobTemplate, templateType string) string {
    for _, template := range templates {
        if strings.ToLower(template.TemplateType) == strings.ToLower(templateType) {
            return template.ID
        }
    }
    return ""
}
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
// Compliance automation workflows
class ComplianceJobManager {
  constructor(jobManager) {
    this.jobManager = jobManager;
  }

  async setupComplianceJobTemplates() {
    // Control testing template
    await this.jobManager.createJobTemplate({
      name: 'Control Testing Automation',
      description: 'Automated testing of control effectiveness',
      templateType: 'COMPLIANCE_TESTING',
      config: {
        test_type: 'automated',
        frameworks: ['SOC2', 'ISO27001'],
        notification: true,
        evidence_required: true
      },
      parameters: {
        control_ids: [],
        test_frequency: 'monthly',
        evidence_types: ['screenshot', 'log', 'document']
      }
    });

    // Evidence collection template
    await this.jobManager.createJobTemplate({
      name: 'Evidence Collection Automation',
      description: 'Automated collection and validation of compliance evidence',
      templateType: 'EVIDENCE_COLLECTION',
      config: {
        collection_methods: ['api', 'file_system', 'database'],
        validation_rules: ['completeness', 'accuracy', 'timeliness'],
        storage_location: 's3://compliance-evidence/'
      },
      parameters: {
        evidence_sources: [],
        collection_schedule: 'daily',
        retention_period: '7_years'
      }
    });

    console.log('Successfully created compliance job templates');
  }

  async scheduleComplianceJobs(programId) {
    const schedules = [
      { name: 'Daily Evidence Collection', template: 'evidence_collection', cron: '0 2 * * *' },
      { name: 'Weekly Control Testing', template: 'control_testing', cron: '0 3 * * 1' },
      { name: 'Monthly Risk Assessment', template: 'risk_assessment', cron: '0 4 1 * *' }
    ];

    for (const schedule of schedules) {
      await this.jobManager.scheduleRecurringJob({
        name: `${schedule.name} - Program ${programId}`,
        description: `Automated ${schedule.name} for compliance program ${programId}`,
        cronSchedule: schedule.cron,
        jobTemplateId: await this.findTemplateByType(schedule.template)
      });
    }
  }
}
```

</TabItem>
</Tabs>

## Job Scheduling

### Cron Schedule Format
Scheduled jobs use standard cron syntax for time-based scheduling:

```
┌───────────── minute (0 - 59)
│ ┌───────────── hour (0 - 23)
│ │ ┌───────────── day of month (1 - 31)
│ │ │ ┌───────────── month (1 - 12)
│ │ │ │ ┌───────────── day of week (0 - 6) (Sunday to Saturday)
│ │ │ │ │
* * * * *
```

### Common Schedule Examples
- `0 2 * * *` - Daily at 2:00 AM
- `0 3 * * 1` - Weekly on Monday at 3:00 AM
- `0 4 1 * *` - Monthly on the 1st at 4:00 AM
- `0 5 * * 1-5` - Weekdays at 5:00 AM
- `*/15 * * * *` - Every 15 minutes

## Monitoring and Logging

### Job Status Tracking
- **QUEUED**: Job is waiting for execution
- **RUNNING**: Job is currently executing
- **COMPLETED**: Job completed successfully
- **FAILED**: Job execution failed
- **CANCELLED**: Job was cancelled before completion

### Job Execution Logs
All job executions generate detailed logs including:
- Start and end timestamps
- Execution parameters
- Progress indicators
- Error messages and stack traces
- Resource utilization metrics

### Alerting and Notifications
Configure alerts for:
- Job failures and errors
- Long-running job detection
- Resource utilization thresholds
- Schedule misses or delays

## Integration with Riverboat

Openlane's job system is built on [Riverboat](https://github.com/theopenlane/riverboat), a Go-based job queue server that provides:

- **Reliable Processing**: At-least-once job delivery guarantees
- **Scalability**: Distributed job processing across multiple workers
- **Persistence**: Job state persistence with PostgreSQL
- **Monitoring**: Built-in job monitoring and metrics
- **Dead Letter Queues**: Failed job handling and retry logic

## Best Practices

### Job Design
1. **Idempotency**: Design jobs to be safely re-runnable
2. **Error Handling**: Implement robust error handling and recovery
3. **Resource Management**: Manage memory and CPU usage appropriately
4. **Logging**: Provide comprehensive logging for debugging and monitoring

### Scheduling
1. **Avoid Conflicts**: Schedule jobs to avoid resource conflicts
2. **Stagger Execution**: Distribute job execution times to balance load
3. **Consider Dependencies**: Account for job dependencies and sequencing
4. **Time Zones**: Use UTC for consistent scheduling across regions

### Security
1. **Access Controls**: Implement appropriate access controls for job management
2. **Secrets Management**: Securely handle credentials and sensitive data
3. **Audit Trails**: Maintain comprehensive audit logs for job activities
4. **Resource Limits**: Implement resource limits to prevent abuse

### Performance
1. **Batch Processing**: Use batch processing for large datasets
2. **Parallel Execution**: Leverage parallel processing where appropriate
3. **Resource Monitoring**: Monitor resource usage and optimize accordingly
4. **Queue Management**: Manage job queues to prevent bottlenecks

The job management system provides essential automation capabilities that enable organizations to scale their compliance operations while maintaining consistency and reliability across all platform activities.