---
title: Overview
description: Compliance questionnaires and assessment management
sidebar_position: 1
---

# Questionnaires

Questionnaires in Openlane provide structured assessment capabilities for compliance evaluation, vendor assessments, security reviews, and organizational maturity assessments. They enable systematic data collection and evaluation across various compliance domains.

## What Are Questionnaires?

Questionnaires are structured assessment tools that facilitate systematic evaluation of compliance posture, security controls, vendor capabilities, and organizational maturity. They provide standardized frameworks for collecting, analyzing, and reporting assessment data across different compliance contexts.

## Key Features

- **Template Management**: Reusable questionnaire templates for common assessments
- **Dynamic Questions**: Conditional question logic based on previous responses
- **Multiple Response Types**: Support for various question types (multiple choice, text, ratings, etc.)
- **Assessment Scoring**: Automated scoring and risk evaluation
- **Response Tracking**: Complete audit trail of responses and changes
- **Reporting**: Comprehensive assessment reports and analytics

## Questionnaire Types

### Security Assessments
- **Control Effectiveness**: Evaluate the effectiveness of security controls
- **Risk Assessments**: Structured risk evaluation questionnaires
- **Vulnerability Assessments**: Security posture evaluation
- **Penetration Test Results**: Structured reporting of security testing

### Vendor Assessments
- **Due Diligence**: Vendor security and compliance evaluation
- **SIG Questionnaires**: Standard Information Gathering questionnaires
- **Third-Party Risk**: Supplier and partner risk assessments
- **Service Provider Evaluation**: Cloud and service provider assessments

### Compliance Evaluations
- **Framework Assessments**: SOC 2, ISO 27001, NIST compliance evaluations
- **Regulatory Compliance**: Industry-specific compliance questionnaires
- **Audit Preparation**: Pre-audit assessment questionnaires
- **Gap Analysis**: Compliance gap identification and analysis

### Organizational Maturity
- **Process Maturity**: Organizational process maturity assessments
- **Security Awareness**: Employee security awareness evaluations
- **Training Effectiveness**: Training program effectiveness assessments
- **Culture Assessment**: Organizational security culture evaluation

## Properties

### Questionnaire Template
- **ID**: Unique identifier for the questionnaire template
- **Name**: Descriptive name for the questionnaire
- **Description**: Purpose and scope of the questionnaire
- **Category**: Assessment category (security, compliance, vendor, etc.)
- **Version**: Template version for change management

### Question Structure
- **Question ID**: Unique identifier for each question
- **Question Text**: The actual question content
- **Question Type**: Type of response expected (multiple choice, text, rating, etc.)
- **Required**: Whether the question is mandatory
- **Conditional Logic**: Rules for when the question should be displayed

### Response Management
- **Response ID**: Unique identifier for each response
- **Question ID**: Reference to the associated question
- **Response Value**: The actual response data
- **Respondent**: User who provided the response
- **Response Date**: When the response was submitted

### Scoring and Evaluation
- **Scoring Rules**: Automated scoring logic for responses
- **Risk Rating**: Calculated risk level based on responses
- **Compliance Score**: Overall compliance score
- **Recommendations**: Automated recommendations based on responses

## API Operations

### Questionnaire Templates

#### Query Questionnaire Templates
```graphql
query GetQuestionnaireTemplates($first: Int, $where: QuestionnaireTemplateWhereInput) {
  questionnaireTemplates(first: $first, where: $where) {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
    edges {
      node {
        id
        name
        description
        category
        version
        questions {
          id
          questionText
          questionType
          required
          options
        }
        createdAt
        updatedAt
      }
    }
  }
}
```

#### Create Questionnaire Template
```graphql
mutation CreateQuestionnaireTemplate($input: CreateQuestionnaireTemplateInput!) {
  createQuestionnaireTemplate(input: $input) {
    questionnaireTemplate {
      id
      name
      description
      category
      version
      questions {
        id
        questionText
        questionType
        required
      }
      createdAt
    }
  }
}
```

### Assessment Responses

#### Submit Questionnaire Response
```graphql
mutation SubmitQuestionnaireResponse($input: SubmitQuestionnaireResponseInput!) {
  submitQuestionnaireResponse(input: $input) {
    questionnaireResponse {
      id
      questionnaireTemplateId
      respondent {
        id
        firstName
        lastName
      }
      responses {
        questionId
        responseValue
        responseDate
      }
      overallScore
      riskRating
      completedAt
    }
  }
}
```

#### Query Assessment Results
```graphql
query GetQuestionnaireResults($templateId: ID!, $first: Int) {
  questionnaireResponses(
    where: { questionnaireTemplateId: { eq: $templateId } }
    first: $first
  ) {
    edges {
      node {
        id
        respondent {
          id
          firstName
          lastName
          email
        }
        overallScore
        riskRating
        completedAt
        responses {
          questionId
          responseValue
          question {
            questionText
            questionType
          }
        }
      }
    }
  }
}
```

## Usage Examples

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

### Questionnaire Management

<Tabs>
<TabItem value="golang" label="Go">

```go
package main

import (
    "context"
    "fmt"
    "log"
    "time"

    "github.com/theopenlane/core/pkg/openlaneclient"
)

// QuestionnaireManager handles questionnaire operations
type QuestionnaireManager struct {
    client *openlaneclient.OpenlaneClient
}

// CreateVendorAssessmentTemplate creates a standard vendor assessment questionnaire
func (qm *QuestionnaireManager) CreateVendorAssessmentTemplate(ctx context.Context) (*QuestionnaireTemplate, error) {
    questions := []QuestionConfig{
        {
            QuestionText: "Does your organization have a formal information security program?",
            QuestionType: "MULTIPLE_CHOICE",
            Required:     true,
            Options:      []string{"Yes", "No", "In Development"},
            Weight:       10,
        },
        {
            QuestionText: "Are security controls reviewed and updated annually?",
            QuestionType: "MULTIPLE_CHOICE",
            Required:     true,
            Options:      []string{"Yes", "No", "Partially"},
            Weight:       8,
        },
        {
            QuestionText: "Describe your data encryption practices",
            QuestionType: "TEXT",
            Required:     true,
            Weight:       7,
        },
        {
            QuestionText: "Rate your organization's security maturity (1-5 scale)",
            QuestionType: "RATING",
            Required:     true,
            Options:      []string{"1", "2", "3", "4", "5"},
            Weight:       9,
        },
    }

    template := &QuestionnaireTemplate{
        Name:        "Vendor Security Assessment",
        Description: "Standard security assessment questionnaire for third-party vendors",
        Category:    "VENDOR_ASSESSMENT",
        Version:     "1.0",
        Questions:   questions,
    }

    // Create the template (this would map to actual GraphQL mutation)
    createdTemplate, err := qm.createTemplate(ctx, template)
    if err != nil {
        return nil, fmt.Errorf("failed to create vendor assessment template: %w", err)
    }

    log.Printf("Created vendor assessment template: %s (%s)", createdTemplate.Name, createdTemplate.ID)
    return createdTemplate, nil
}

// CreateComplianceGapAssessment creates a compliance gap analysis questionnaire
func (qm *QuestionnaireManager) CreateComplianceGapAssessment(ctx context.Context, framework string) (*QuestionnaireTemplate, error) {
    var questions []QuestionConfig

    // Dynamic question generation based on framework
    switch framework {
    case "SOC2":
        questions = []QuestionConfig{
            {
                QuestionText: "Are user access reviews conducted quarterly?",
                QuestionType: "MULTIPLE_CHOICE",
                Required:     true,
                Options:      []string{"Yes", "No", "Semi-Annually", "Annually"},
                Weight:       10,
            },
            {
                QuestionText: "Is multi-factor authentication enforced for all users?",
                QuestionType: "MULTIPLE_CHOICE",
                Required:     true,
                Options:      []string{"Yes", "No", "For Privileged Users Only"},
                Weight:       9,
            },
            {
                QuestionText: "Describe your change management process",
                QuestionType: "TEXT",
                Required:     true,
                Weight:       8,
            },
        }
    case "ISO27001":
        questions = []QuestionConfig{
            {
                QuestionText: "Is there a documented Information Security Management System (ISMS)?",
                QuestionType: "MULTIPLE_CHOICE",
                Required:     true,
                Options:      []string{"Yes", "No", "In Development"},
                Weight:       10,
            },
            {
                QuestionText: "Are security incidents formally tracked and managed?",
                QuestionType: "MULTIPLE_CHOICE",
                Required:     true,
                Options:      []string{"Yes", "No", "Partially"},
                Weight:       9,
            },
        }
    default:
        return nil, fmt.Errorf("unsupported framework: %s", framework)
    }

    template := &QuestionnaireTemplate{
        Name:        fmt.Sprintf("%s Compliance Gap Assessment", framework),
        Description: fmt.Sprintf("Gap analysis questionnaire for %s compliance", framework),
        Category:    "COMPLIANCE_GAP",
        Version:     "1.0",
        Questions:   questions,
    }

    createdTemplate, err := qm.createTemplate(ctx, template)
    if err != nil {
        return nil, fmt.Errorf("failed to create compliance gap assessment: %w", err)
    }

    return createdTemplate, nil
}

// SubmitQuestionnaireResponse submits responses to a questionnaire
func (qm *QuestionnaireManager) SubmitQuestionnaireResponse(ctx context.Context, templateID string, responses []ResponseData) (*QuestionnaireResponse, error) {
    responseInput := &SubmitResponseInput{
        QuestionnaireTemplateID: templateID,
        Responses:               responses,
        SubmittedAt:            time.Now(),
    }

    // Calculate overall score
    totalScore := 0
    totalWeight := 0
    for _, response := range responses {
        score := qm.calculateResponseScore(response)
        totalScore += score * response.Weight
        totalWeight += response.Weight
    }

    overallScore := 0
    if totalWeight > 0 {
        overallScore = totalScore / totalWeight
    }

    responseInput.OverallScore = overallScore
    responseInput.RiskRating = qm.calculateRiskRating(overallScore)

    // Submit the response (this would map to actual GraphQL mutation)
    submittedResponse, err := qm.submitResponse(ctx, responseInput)
    if err != nil {
        return nil, fmt.Errorf("failed to submit questionnaire response: %w", err)
    }

    log.Printf("Submitted questionnaire response with score: %d", overallScore)
    return submittedResponse, nil
}

// AnalyzeAssessmentResults analyzes questionnaire results for insights
func (qm *QuestionnaireManager) AnalyzeAssessmentResults(ctx context.Context, templateID string) (*AssessmentAnalysis, error) {
    // Get all responses for the template
    responses, err := qm.getResponsesByTemplate(ctx, templateID)
    if err != nil {
        return nil, fmt.Errorf("failed to get responses: %w", err)
    }

    analysis := &AssessmentAnalysis{
        TemplateID:      templateID,
        TotalResponses:  len(responses),
        AnalyzedAt:     time.Now(),
    }

    if len(responses) == 0 {
        return analysis, nil
    }

    // Calculate statistics
    totalScore := 0
    riskCounts := make(map[string]int)

    for _, response := range responses {
        totalScore += response.OverallScore
        riskCounts[response.RiskRating]++
    }

    analysis.AverageScore = float64(totalScore) / float64(len(responses))
    analysis.RiskDistribution = riskCounts

    // Identify common gaps
    analysis.CommonGaps = qm.identifyCommonGaps(responses)

    // Generate recommendations
    analysis.Recommendations = qm.generateRecommendations(analysis)

    return analysis, nil
}

// Helper functions and types
type QuestionnaireTemplate struct {
    ID          string
    Name        string
    Description string
    Category    string
    Version     string
    Questions   []QuestionConfig
    CreatedAt   time.Time
}

type QuestionConfig struct {
    ID           string
    QuestionText string
    QuestionType string
    Required     bool
    Options      []string
    Weight       int
}

type ResponseData struct {
    QuestionID    string
    ResponseValue string
    Weight        int
}

type QuestionnaireResponse struct {
    ID                      string
    QuestionnaireTemplateID string
    RespondentID            string
    Responses              []ResponseData
    OverallScore           int
    RiskRating             string
    CompletedAt            time.Time
}

type SubmitResponseInput struct {
    QuestionnaireTemplateID string
    Responses              []ResponseData
    OverallScore           int
    RiskRating             string
    SubmittedAt            time.Time
}

type AssessmentAnalysis struct {
    TemplateID        string
    TotalResponses    int
    AverageScore      float64
    RiskDistribution  map[string]int
    CommonGaps        []string
    Recommendations   []string
    AnalyzedAt        time.Time
}

// calculateResponseScore calculates a numeric score for a response
func (qm *QuestionnaireManager) calculateResponseScore(response ResponseData) int {
    // Simplified scoring logic
    switch response.ResponseValue {
    case "Yes":
        return 10
    case "No":
        return 0
    case "Partially", "In Development":
        return 5
    case "5":
        return 10
    case "4":
        return 8
    case "3":
        return 6
    case "2":
        return 4
    case "1":
        return 2
    default:
        return 5 // Default score for text responses
    }
}

// calculateRiskRating determines risk rating based on overall score
func (qm *QuestionnaireManager) calculateRiskRating(score int) string {
    switch {
    case score >= 8:
        return "LOW"
    case score >= 6:
        return "MEDIUM"
    case score >= 4:
        return "HIGH"
    default:
        return "CRITICAL"
    }
}

// Placeholder functions for actual implementation
func (qm *QuestionnaireManager) createTemplate(ctx context.Context, template *QuestionnaireTemplate) (*QuestionnaireTemplate, error) {
    // Implementation would call actual GraphQL API
    template.ID = "template_" + fmt.Sprintf("%d", time.Now().Unix())
    template.CreatedAt = time.Now()
    return template, nil
}

func (qm *QuestionnaireManager) submitResponse(ctx context.Context, input *SubmitResponseInput) (*QuestionnaireResponse, error) {
    // Implementation would call actual GraphQL API
    return &QuestionnaireResponse{
        ID:                      "response_" + fmt.Sprintf("%d", time.Now().Unix()),
        QuestionnaireTemplateID: input.QuestionnaireTemplateID,
        OverallScore:           input.OverallScore,
        RiskRating:             input.RiskRating,
        CompletedAt:            input.SubmittedAt,
    }, nil
}

func (qm *QuestionnaireManager) getResponsesByTemplate(ctx context.Context, templateID string) ([]*QuestionnaireResponse, error) {
    // Implementation would call actual GraphQL API
    return []*QuestionnaireResponse{}, nil
}

func (qm *QuestionnaireManager) identifyCommonGaps(responses []*QuestionnaireResponse) []string {
    // Analyze responses to identify common gaps
    return []string{"Multi-factor authentication not fully implemented", "Quarterly access reviews not conducted"}
}

func (qm *QuestionnaireManager) generateRecommendations(analysis *AssessmentAnalysis) []string {
    recommendations := []string{}

    if analysis.AverageScore < 7 {
        recommendations = append(recommendations, "Consider implementing additional security controls")
    }

    if analysis.RiskDistribution["HIGH"]+analysis.RiskDistribution["CRITICAL"] > analysis.TotalResponses/2 {
        recommendations = append(recommendations, "High-risk findings require immediate attention")
    }

    return recommendations
}
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
// Questionnaire management and assessment workflows
class QuestionnaireManager {
  constructor(client) {
    this.client = client;
  }

  async createVendorAssessmentTemplate() {
    const questions = [
      {
        questionText: "Does your organization have a formal information security program?",
        questionType: "MULTIPLE_CHOICE",
        required: true,
        options: ["Yes", "No", "In Development"],
        weight: 10
      },
      {
        questionText: "Are security controls reviewed and updated annually?",
        questionType: "MULTIPLE_CHOICE",
        required: true,
        options: ["Yes", "No", "Partially"],
        weight: 8
      },
      {
        questionText: "Describe your data encryption practices",
        questionType: "TEXT",
        required: true,
        weight: 7
      }
    ];

    const template = {
      name: "Vendor Security Assessment",
      description: "Standard security assessment questionnaire for third-party vendors",
      category: "VENDOR_ASSESSMENT",
      version: "1.0",
      questions: questions
    };

    const createdTemplate = await this.client.createQuestionnaireTemplate(template);
    console.log(`Created vendor assessment template: ${createdTemplate.name}`);
    return createdTemplate;
  }

  async submitQuestionnaireResponse(templateId, responses) {
    // Calculate overall score
    const totalScore = responses.reduce((sum, response) => {
      const score = this.calculateResponseScore(response);
      return sum + (score * response.weight);
    }, 0);

    const totalWeight = responses.reduce((sum, response) => sum + response.weight, 0);
    const overallScore = totalWeight > 0 ? Math.round(totalScore / totalWeight) : 0;

    const responseInput = {
      questionnaireTemplateId: templateId,
      responses: responses,
      overallScore: overallScore,
      riskRating: this.calculateRiskRating(overallScore),
      submittedAt: new Date().toISOString()
    };

    const submittedResponse = await this.client.submitQuestionnaireResponse(responseInput);
    console.log(`Submitted questionnaire response with score: ${overallScore}`);
    return submittedResponse;
  }

  calculateResponseScore(response) {
    switch (response.responseValue) {
      case "Yes": return 10;
      case "No": return 0;
      case "Partially":
      case "In Development": return 5;
      case "5": return 10;
      case "4": return 8;
      case "3": return 6;
      case "2": return 4;
      case "1": return 2;
      default: return 5; // Default for text responses
    }
  }

  calculateRiskRating(score) {
    if (score >= 8) return "LOW";
    if (score >= 6) return "MEDIUM";
    if (score >= 4) return "HIGH";
    return "CRITICAL";
  }
}
```

</TabItem>
</Tabs>

## Assessment Scoring

### Scoring Methodology
- **Weighted Scoring**: Questions are assigned weights based on importance
- **Automatic Calculation**: Overall scores are calculated automatically
- **Risk Rating**: Scores are converted to risk ratings (LOW, MEDIUM, HIGH, CRITICAL)
- **Trend Analysis**: Historical scoring to track improvement over time

### Score Interpretation
- **90-100**: Excellent - Minimal risk, strong controls
- **80-89**: Good - Low risk, effective controls
- **70-79**: Fair - Medium risk, some gaps identified
- **60-69**: Poor - High risk, significant gaps
- **Below 60**: Critical - Immediate attention required

## Reporting and Analytics

### Assessment Reports
- **Individual Results**: Detailed results for specific assessments
- **Comparative Analysis**: Compare results across different assessments
- **Trend Reports**: Track improvement over time
- **Gap Analysis**: Identify common weaknesses and gaps

### Dashboard Metrics
- **Assessment Completion Rates**: Track response rates and completion
- **Risk Distribution**: Visual representation of risk levels
- **Score Trends**: Historical score progression
- **Action Items**: Generated recommendations and follow-up actions

## Best Practices

### Questionnaire Design
1. **Clear Questions**: Write clear, unambiguous questions
2. **Logical Flow**: Organize questions in a logical sequence
3. **Appropriate Length**: Balance thoroughness with user experience
4. **Regular Updates**: Keep questionnaires current with evolving requirements

### Assessment Process
1. **Training**: Provide training on assessment completion
2. **Documentation**: Maintain supporting documentation
3. **Review Process**: Implement review processes for completed assessments
4. **Follow-up**: Establish follow-up processes for identified gaps

### Data Management
1. **Data Privacy**: Protect sensitive assessment data
2. **Access Controls**: Implement appropriate access controls
3. **Retention Policies**: Establish data retention and archival policies
4. **Audit Trails**: Maintain complete audit trails for all activities

Questionnaires provide essential assessment capabilities that enable systematic evaluation of compliance posture, security controls, and organizational maturity across all areas of the Openlane platform.