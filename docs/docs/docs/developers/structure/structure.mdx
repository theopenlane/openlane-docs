---
title: Source Code Structure
description: The structure of the Openlane source code
sidebar_position: 1
---

# Project Structure - Core

[Core](https://github.com/theopenlane/core) is the main server for Openlane and where the majority of the backend code and business logic is 
located for the API. 

## cmd

### server

Located in `cmd/` this is a cobra cli that will start up the main core server. The `Taskfile` included in the repo provides the common commands but under the hood
the `serve` command is what is being used

```bash
 go run main.go serve --debug --pretty
```

### cli

Located in `cmd/cli/cmd` this directory includes all the CRUD operations for the openlane cli. As these follow a pretty similar pattern throughout 
all objects, there is a template that allows these files to be generated and only requires the input and output fields to be updated. 

## config

Located in `config/` this directory contains the generated config and example settings powered by [koanf](https://github.com/knadh/koanf). 

## internal 

The meat of the repo, if you are looking for something, it's probably in this directory somewhere. Everything in the `internal` directory is intended to only be used by packages within this repository, outside usage will be blocked by the go-compiler.

### ent

Located in `internal/ent` this directory contains all the code related to the schemas. 

```
├── internal
│   ├── ent
│   │   ├── generated
│   │   ├── hooks
│   │   ├── interceptors
│   │   ├── mixin
│   │   ├── privacy
│   │   ├── schema
│   │   ├── templates
│   │   └── validator
```

#### generated 

All code generated by `entc` is in this directory and should not be edited manually as changes will be overwritten on the next run of `task generate`. 

#### hooks

This contains all `hooks` written to change the behavior of a mutation. Think of a hook as a middleware that can occur before or after the mutation is executed.

```go
// HookExample is a hook that is used as an example that only happens on `Create` operations
func HookExample() ent.Hook {
	return hook.On(func(next ent.Mutator) ent.Mutator {
		return hook.ExampleFunc(func(ctx context.Context, m *generated.ExampleMutation) (generated.Value, error) {
            // code here will occur before the example mutation is executed

            retVal, err := next.Mutate(ctx, m)
            if err != nil {
                return nil, err
            }

            // code here will occur after the example mutation is executed

			return retVal, err
		})
	}, ent.OpCreate) // only do the thing on create operations, this can be omitted completely or include multiple operations separated by `|`
}
```

For more information, refer to the upstream [docs](https://entgo.io/docs/hooks/)

#### interceptors

This contains all `interceptors` written to change the behavior of a query. These are similar to hooks, but instead of acting on a mutation, it acts on a query. 

`Traverse` functions occur before the query is executed
`Interceptor` functions occur after the query is executed 

We commonly use these to filter data the user has access to, or log information such as query timing 

For more information, refer to the upstream [docs](https://entgo.io/docs/interceptors)


#### privacy 

This includes privacy policies, this is used in conjunction with our FGA implementation

For more information, refer to the upstream [docs](https://entgo.io/docs/privacy)

#### schema

This include all schemas for the database. When generating a new schema, refer to the [new schema](../ent/#creating-a-new-schema) documentation

#### mixin

Mixins are common fields and functions that are used on multiple schemas, for example, the `SoftDeleteMixin` is used on all schemas as we want to use soft-deletes
across all our database tables. 

:::note
not **all** mixins are here. Due to import cycles, some are located within the `schema` directory. Others, because they are not unique to this repository are located within the [entx](https://github.com/theopenlane/entx/tree/main/mixin) repository
::: 

### graphapi 

Located in `internal/graphapi` this directory contains all the code related to graphapi resolvers. The `*.resolvers.go` files contain the business logic of the 
resolvers. These are generated based on the schema and a template, but the generated should be reviewed and updated as needed depending on the use case.

All graphapi resolvers require authentication, this is handled by the auth middleware and requires no updates to the resolvers themselves.

```
├── internal
│   ├── graphapi
│   │   ├── clientschema
│   │   ├── generate
│   │   ├── generated
│   │   ├── model
│   │   ├── query
│   │   ├── schema
│   │   └── testdata
```

#### query

The `internal/graphapi/query` directory contains queries and mutations used to generate the `openlaneclient` using [gqlgenc](https://github.com/Yamashou/gqlgenc)

### httpserve

Located in `internal/httpserve` this directory contains the main http server and configuration as well as the `REST` api handlers and routes. Although the 
majority of the openlane API is a graphapi, there are several `REST` routes such as `login`, `password-reset`, etc. 

```
├── internal
│   ├── httpserve
│   │   ├── authmanager
│   │   ├── config
│   │   ├── handlers
│   │   ├── route
│   │   ├── server
│   │   └── serveropts
```

### handlers

This directory contains the `REST` api handlers. The general use-case should not require a REST endpoint, however, there are several cases where REST handlers have
been implemented such as for `login`. Handlers should all follow the same pattern of created a Handler and a BindHandler, for openAPI specs. 

```go
func (h *Handler) ExampleHandler(ctx echo.Context) error {
	// bind the input
	var in models.ExampleRequest
	if err := ctx.Bind(&in); err != nil {
		return h.InvalidInput(ctx, err)
	}

	// validate the input
	if err := in.Validate(); err != nil {
		return h.InvalidInput(ctx, err)
	}

	// 
	// ... do some stuff ...
	// 

	
	// return the response
	out := models.ExampleReply{
		Reply:    rout.Reply{Success: true},
		Message:  "success",
	}

	return h.Success(ctx, out)
}

// BindExampleHandler binds the example request to the OpenAPI schema
func (h *Handler) BindExampleHandler() *openapi3.Operation {
	example := openapi3.NewOperation()
	example.Description = "Example is ... "
	example.Tags = []string{"example"}
	example.OperationID = "ExampleHandler"

	h.AddRequestBody("ExampleRequest", models.ExampleExampleSuccessRequest, example)
	h.AddResponse("ExampleReply", "success", models.ExampleExampleSuccessResponse, example, http.StatusOK)
	example.AddResponse(http.StatusInternalServerError, internalServerError())
	example.AddResponse(http.StatusBadRequest, badRequest())

	return example
}
```


### routes

All handlers must be registered routes with the `echo` server. Once a handler is created, a route should be added here. These all follow a predictable pattern

```go
func registerExampleHandler(router *Router) (err error) {
	path := "/example"
	method := http.MethodPost
	name := "Example"

	route := echo.Route{
		Name:        name,
		Method:      method,
		Path:        path,
		Middlewares: mw,
		Handler: func(c echo.Context) error {
			return router.Handler.ExampleHandler(c)
		},
	}

	op := router.Handler.BindExampleHandler()

	if err := router.Addv1Route(path, method, op, route); err != nil {
		return err
	}

	return nil
}
```

The default middleware (`mw`) is an unauthenticated route. If the REST endpoint should require authentication `authMW` should be used instead.

## pkg

### middleware

The `pkg/middleware` contains many commonly used `middleware` used in this repository. These may move to internal if they are dependent on the schema, 
or to another repo at some point in the future. 

```
├── pkg
│   ├── middleware
│   │   ├── auth
│   │   ├── cachecontrol
│   │   ├── cors
│   │   ├── debug
│   │   ├── mime
│   │   ├── ratelimit
│   │   ├── ratelimiter
│   │   ├── redirect
│   │   ├── secure
│   │   └── transaction
```

### models

Located in `pkg/models` this includes all the model information for the `REST` api input and output. This is used to generate our openAPI specs. 

### openlaneclient

Located in `pkg/openlaneclient` this includes the generated golang API client used to interact with the API. The queries added to `internal/graphapi/query` 
are used as input to `gqlgenc` for the graphclient. The restclient is manually maintained. 
